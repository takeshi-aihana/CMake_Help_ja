ユーザ操作ガイド
****************

.. only:: html

   .. contents::

はじめに
========

あるソフトウェア・パッケージが、そのソースファイルと共に CMake ベースのビルドシステムを提供している場合、そのソフトウェアを利用する開発者はユーザ向けに用意された CMake ツールを実行してビルドする必要があります。

「行儀の良い」CMake ベースのビルドシステムは、ビルドした結果をソースディレクトリに出力するようなことはしません。そのため通常、ユーザはソースディレクトリの外でビルドを実行することになります。
まず CMake に適切なビルドシステムを生成するよう指示し、ビルド・ツールを呼び出してそのビルドシステムを処理します。
このビルドシステムはそれを生成したマシンに固有のものであり、再配布できるものではありません。
ソフトウェア・パッケージを利用する開発者は、それぞれ自分たちのシステムに固有のビルドシステムを CMake を使って生成する必要があります。

ここで生成したビルドシステムは、原則的に読み取り専用として扱って下さい。
「一時生成物（Primary Artifacts）」として CMake が作成したファイルはビルドシステムを定義するプロパティであり、ビルドシステムを生成した後に、たとえば IDE でそのようなプロパティを手動で設定する必要はありません。
CMake はビルドシステムを定期的に書き換えるので、ユーザがプロパティを変更しても上書きされてしまいます。

このマニュアルで説明している機能とユーザ・インタフェースは、すべての CMake ベースのビルドシステムで利用可能です。

CMake のツールで CMake が作成したファイルを処理している時、例えばコンパイラがサポートされていないとか、コンパイラが必要なコンパイル・オプションをサポートしていないとか、あるいは依存関係が見つからなかったなどのエラーをユーザに報告する場合があります。
これらのエラーは、別のコンパイラを選択するとか、「:guide:`依存関係のインストール <依存関係を利用するためのガイド>`」とか、あるいは依存関係を見つける場所を CMake に指示するなどして、ユーザ自身で解決する必要があります。

コマンドライン cmake ツール
----------------------------

単純ですが、ソフトウェアの新しいコピーに対する :manual:`cmake(1)` の典型的な使い方は、まずビルド・ディレクトリを作成し、そのデレクトリで ``cmake`` を呼び出します：

.. code-block:: console

  $ cd some_software-1.4.2
  $ mkdir build
  $ cd build
  $ cmake .. -DCMAKE_INSTALL_PREFIX=/opt/the/prefix
  $ cmake --build .
  $ cmake --build . --target install

ソース・ディレクトリとは別のディレクトリでビルドすることが推奨されます。これによりソース・ディレクトリは初期の状態に保たれ、複数のツールチェインで同一のソースをビルドすることができ、ビルド・ディレクトリを削除するだけでビルド時の生成物を簡単にクリーンできます。

CMake のツールは、ソフトウェアの利用者ではなく、ソフトウェアを提供する開発者向けの警告をいろいろ報告する場合があります。
このような警告の多くは "This warning is for project developers" という注意書きが付いています。
このような警告は :option:`-Wno-dev <cmake -Wno-dev>` というフラグを :manual:`cmake(1)` に渡すことで無効にできます。

cmake-gui ツール
----------------

GUI インタフェースに慣れているユーザであれば :manual:`cmake-gui(1)` ツールを使い、CMake を呼び出してビルドシステムを生成することができます。

最初にソース・ディレクトリとビルド・ディレクトリを設定して下さい。
ソースとビルドには異なるディレクトリを指定することが推奨されます。

.. image:: GUI-Source-Binary.png
   :alt: Choosing source and binary directories

ビルドシステムの生成
====================

CMake のファイルから任意のビルドシステムを生成する時に、利用できるユーザ向けのツールがいくつかあります。
:manual:`ccmake(1)` と :manual:`cmake-gui(1)` といったツールは、いろいろ必要なオプション設定をユーザに提示してくれます。
:manual:`cmake(1)` は、コマンドラインからオプションを指定して呼び出せます。
このマニュアルではどのツールからでも設定できる共通のオプションについて説明していますが、オプションを設定するモードはツールごとに異なるので注意して下さい。

コマンドライン環境
------------------

``Makefiles`` または ``Ninja`` といったコマンドライン型のビルドシステムと一緒に :manual:`cmake(1)` を呼び出すときは、正しいビルド環境を指定して、正しいビルド・ツールが利用できることを保証する必要があります。
CMake は、必要に応じて適切な :variable:`build tool <CMAKE_MAKE_PROGRAM>` やコンパイラやリンカ、その他のツールを見つけられなければなりません。

Linux システムでは、大抵の場合、適切なツールが既にシステムにインストールされており、パッケージ・マネージャを使って簡単に追加することができるようになっています。
ユーザが独自にインストールしたり、デフォルトの場所以外にインストールしたその他のツールチェインも利用できます。

クロス・コンパイルする際、一部のプラットフォームでは環境変数を設定したり、環境を設定するためのスクリプトを用意する必要があるかもしれません。

Visual Studio には、コマンドライン型のビルドシステム向けに正しい環境を設定する複数のコマンドライン・プロンプトと ``vcvarsall.bat`` というスクリプトが同梱されています。 
Visual Studio のジェネレータを使う時に、必ず対応するコマンドライン環境を使用しなければならないわけではありませんが、そうすることにデメリットはありません。

Xcode を使う際、複数のバージョンの Xcode がインストールされているかもしれません。
どのバージョンを使うかはいろいろな方法で選択できますが、最も一般的な方法は次のとおりです：

* Xcode の IDE にある設定画面でデフォルトのバージョンを指定する
* コマンドライン・ツールである ``xcode-select`` を使ってデフォルトのバージョンを指定する
* CMake とビルド・ツールを実行する際に、環境変数の ``DEVELOPER_DIR`` にセットした値でデフォルトのバージョンを上書きする

なお :manual:`cmake-gui(1)` には環境変数の値を編集する機能があります。

コマンドラインの ``-G`` オプション
----------------------------------

CMake は、デフォルトでプラットフォームに基づいたジェネレータを選択します。
通常ユーザがソフトウェアをビルドする場合、デフォルトで選択されたジェネレータで十分です。

ユーザは :option:`-G <cmake -G>` というオプションでデフォルトのジェネレータを上書き指定できます：

.. code-block:: console

  $ cmake .. -G Ninja

:option:`cmake --help` を実行すると、ユーザが選択できる :manual:`generators <cmake-generators(7)>` の一覧が出力されます。
これらのジェネレータの名前は大小文字を区別するので注意して下さい。

Unix 系のシステム（含む Mac OS X）では :generator:`Unix Makefiles` がデフォルトのジェネレータです。
:generator:`NMake Makefiles` や :generator:`MinGW Makefiles` など、いろいろな派生型のジェネレータを Windows のさまざまな環境で利用することもできます。
これらのジェネレータは、``make`` や ``gmake`` や ``nmake``、あるいは同様のツールで解釈が可能な ``Makefile`` を作成します。
ジェネレータが対象としている環境やツールについて詳細は、それぞれのドキュメントを参照して下さい。

:generator:`Ninja` は主要なプラットフォームで利用可能なジェネレータの一つです。
``ninja`` は ``make`` と似たユース・ケースを持つビルド・ツールですが、パフォーマンスと処理効率を重視したものになっています。

Windows の場合、:manual:`cmake(1)` で Visual Studio IDE 向けのソリューションを生成できます。
Visual Studio のバージョンは、4桁の年を含む IDE の製品名で指定します。
エイリアスは、Visual C++ コンパイラの製品バージョンを表す2桁を指定する、あるいはそれらを組み合わせるなどして、Visual Studio のバージョンを参照する別の指定方として利用できます：

.. code-block:: console

  $ cmake .. -G "Visual Studio 2019"
  $ cmake .. -G "Visual Studio 16"
  $ cmake .. -G "Visual Studio 16 2019"

Visual Studio のジェネレータは、いろいろなアーキテクチャのターゲットをサポートしています。
:option:`-A <cmake -A>` オプションでターゲットのアーキテクチャを指定できます：

.. code-block:: console

  cmake .. -G "Visual Studio 2019" -A x64
  cmake .. -G "Visual Studio 16" -A ARM
  cmake .. -G "Visual Studio 16 2019" -A ARM64

Mac OS X の場合、:generator:`Xcode` というジェネレータを使って Xcode IDE 向けのプロジェクト・ファイルを作成成します。

KDevelop4 や QtCreator や CLion のような一部の IDE は CMake ベースのビルドシステムをネイティブでサポートしています。

これらの IDE はジェネレータを選択するためのユーザ・インタフェースを提供しており、通常は ``Makefile`` から ``Ninja`` 系のジェネレータを選択します。

CMake を一度呼び出した後に、:option:`-G <cmake -G>` でジェネレータを変更することはできないことに注意して下さい。
ジェネレータを変更するには、まずビルド・ディレクトリを削除して、最初からビルドシステムを生成する必要があります。

Visual Studio のプロジェクトとソリューションのファイルを作成する場合、:manual:`cmake(1)` を初めて実行する時に他のオプションを指定できます。

Visual Studio のツールセットは :option:`cmake -T` オプションで指定できます：

.. code-block:: console

    $ # clang-cl ツールセットでビルドする
    $ cmake.exe .. -G "Visual Studio 16 2019" -A x64 -T ClangCL
    $ # Windows XP をターゲットにしてビルドする
    $ cmake.exe .. -G "Visual Studio 16 2019" -A x64 -T v120_xp

:option:`-A <cmake -A>` オプションでターゲット・アーキテクチャを指定し、:option:`-T <cmake -T>` オプションで使用するツールチェインの詳細を指定します。
たとえば ``-Thost=x64`` はホスト・ツールの 64ビット版を選択するように CMake に指示しています。
次の例は、64ビット版のツールを使い、64ビットのターゲット・アーキテクチャをビルドする方法を示しています：

.. code-block:: console

    $ cmake .. -G "Visual Studio 16 2019" -A x64 -Thost=x64

cmake-gui でジェネレータを選択する
----------------------------------

"Configure" ボタンを押すと、CMake で使用するジェネレータを選択するダイアログが表示されます。

.. image:: GUI-Configure-Dialog.png
   :alt: Configuring a generator

コマンドラインから指定できる全てのジェネレータが :manual:`cmake-gui(1)` でも利用できます。

.. image:: GUI-Choose-Generator.png
   :alt: Choosing a generator

Visual Studio のジェネレータを選択する際は、生成するアーキテクチャを設定するための追加オプションが表示されます。

.. image:: VS-Choose-Arch.png
   :alt: Choosing an architecture for Visual Studio generators

.. _`Setting Build Variables`:

ビルド用の変数をセットする
==========================

ソフトウェアのプロジェクトの中には CMake を呼び出す際にコマンドラインに渡す変数が必要になる場合がよくあります。
以下の表に、もっともよく使用する CMake 変数の一部を示します：

========================================== ============================================================
 変数                                       意味
========================================== ============================================================
 :variable:`CMAKE_PREFIX_PATH`              「:guide:`依存関係 <依存関係を利用するためのガイド>`」
                                            を探すパス
 :variable:`CMAKE_MODULE_PATH`              CMake の追加モジュールを探すパス
 :variable:`CMAKE_BUILD_TYPE`               デバッグ／最適化のフラグを決定するビルド構成の種類で、
                                            ``Debug`` または ``Release`` 。
                                            これは ``Makefile`` と ``Ninja`` などの単一構成の
                                            ビルドシステムにのみ適用される。 
                                            Visual Studio や Xcode などの複数構成をサポートする
                                            ビルドシステムでは無視する。
 :variable:`CMAKE_INSTALL_PREFIX`           ``install`` のビルド・ターゲットで、ソフトウェアを
                                            インストールするパス
 :variable:`CMAKE_TOOLCHAIN_FILE`           :manual:`ツールチェインと sysroot <cmake-toolchains(7)>`
                                            で説明したクロス・コンパイル用のデータが格納されたファイル
 :variable:`BUILD_SHARED_LIBS`              :command:`add_library` コマンドで値を指定しなかった場合、
                                            静的ライブラリではなく共有ライブラリをビルドする
 :variable:`CMAKE_EXPORT_COMPILE_COMMANDS`  clang 系のツールで使用する ``compile_commands.json`` を
                                            作成する
========================================== ============================================================

プロジェクトのコンポーネントを有効にしたり無効にするなど、プロジェクト固有のビルドを制御する変数が利用できる場合があります。

さまざまなビルドシステムに対応した変数名の付け方を CMake で規定することはありません。ただし接頭子が ``CMAKE_`` の変数は、CMake が提供しているオプションを参照するため、独自の接頭子が必要なサードパーティのプロジェクトでは、これと同名のオプションを定義しないようにして下さい。
:manual:`cmake-gui(1)` ツールは接頭子ごとにグループ化してオプションを表示できるので、サードパーティが定義する独自の接頭子の参照が保証されます。


コマンドラインから変数をセットする
----------------------------------

CMake の変数をコマンドラインから指定できるのは、はじめてビルドシステムを生成する時：

.. code-block:: console

    $ mkdir build
    $ cd build
    $ cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Debug

または、ビルドシステムを生成したあとに :manual:`cmake(1)` を呼び出す時です：

.. code-block:: console

    $ cd build
    $ cmake . -DCMAKE_BUILD_TYPE=Debug

:option:`-U <cmake -U>` オプションは :manual:`cmake(1)` コマンドラインで指定した変数の値を解除する（キャッシュ変数を削除する）際に使用します：

.. code-block:: console

    $ cd build
    $ cmake . -UMyPackage_DIR

CMake のコマンドラインで生成したビルドシステムは、:manual:`cmake-gui(1)` を使用して変更することができます（その逆も可能）。

:manual:`cmake(1)` ツールで :option:`-C <cmake -C>` オプションを使い初期キャッシュを保存するファイルを指定できます。
これは、同じキャッシュ変数を繰り返し必要とするコマンドとスクリプトを単純化する際に便利な機能です。


cmake-gui で変数をセットする
----------------------------

変数は :manual:`cmake-gui(1)` からセットできる場合があります。
"Add Entry" ボタンをクリックすると変数の値をセットするダイアログが表示されます。

.. image:: GUI-Add-Entry.png
   :alt: Editing a cache entry

:manual:`cmake-gui(1)` ユーザ・インタフェースを利用して、既存の変数を編集できます。

CMake キャッシュ
----------------

CMake を実行する時は、使用するコンパイラやその他のツール、そして依存するライブラリなどの在り処を見つける必要があります。
さらにコンパイル時やリンク時のフラグ、あるいは依存するライブラリへのパスは同じものを使い、常に一貫性のあるビルドシステムを再生成できるようにする必要があります。
そのようなパラメータはユーザの環境に固有の情報なので、ユーザによる修正や変更を可能にしておく必要もあります。

CMake を初めて実行すると、ビルド・ディレクトリの中に ``CMakeCache.txt`` というキャッシュ・ファイルが作成されます。このファイルには、そのようなパラメータが Key/Value ペアの形式で格納されています。
ユーザは :manual:`cmake-gui(1)` または :manual:`ccmake(1)` ツールで、このキャッシュ・ファイルの情報を表示したり編集することができます。
これらのツールは、キャシュ情報を編集した後に必要に応じてソフトウェアを再構成したり、ビルドシステムを再生成するための対話型インタフェースを提供しています。
このツールの中では、キャッシュ情報に関連付けられた短い説明文（ヘルプ）も表示される場合があります。

また、それぞれのキャッシュ情報は型を持ち、その型に応じでツールの中で見え方や操作が異なる場合があります。
たとえば ``BOOL`` 型のキャシュ情報はチェックボックスのユーザ・インタフェースで編集でき、``STRING`` 型はテキストボックス、``FILEPATH`` 型は ``STRING`` と同様にファイルシステム上のパスを特定するための手段としてファイル・ダイアログを提供しています。
:manual:`cmake-gui(1)` ツールの場合、``STRING`` 型のキャッシュ情報には、選択可能な文字列が一覧になったドロップ・ダウン形式のリストが提供される場合があります
（詳細はキャッシュ・プロパティの :prop_cache:`STRINGS` を参照して下さい）。

パラメータとして論理型の値については、ソフトウェア・パッケージに同梱されている CMake 関連のファイルの中で :command:`option` コマンドを使って定義できる場合があります。
このコマンドは、パラメータを説明するヘルプとデフォルト値を含むキャッシュ情報を生成します。
通常、このようなキャッシュ情報はソフトウェアに固有の情報であり、ビルド時にテストやサンプルをビルドするかどうか、あるいは例外を有効にしてビルドするかどうか等の設定に影響するものです。


プリセットを使う
================

CMake は通常プリセットで使用する設定を保存するために ``CMakePresets.json`` ファイルの他、ユーザが独自に設定した ``CMakeUserPresets.json`` ファイルを理解します。
これらのプリセットにはビルド・ディレクトリやジェネレータ、キャシュ情報、環境変数、およびその他のコマンドライン・オプションをセットできます。
これらの設定は全てユーザが上書きで再設定できます。
``CMakePresets.json`` ファイルの書式について詳細はマニュアルの :manual:`cmake-presets(7)` を参照して下さい。

コマンドラインからプリセットを使う
----------------------------------

:manual:`cmake(1)` コマンドラインを使う際に :option:`--preset <cmake --preset>` オプションを使ってプリセットを呼び出すことができます。
この :option:`--preset <cmake --preset>` を指定すると、コマンドラインからジェネレータとビルド・ディレクトリの指定は必須ではなくなりますが、指定した場合はこれらプリセットの値が上書きされます。
例えば、次のような ``CMakePresets.json`` ファイルがあるとします：

.. code-block:: json

  {
    "version": 1,
    "configurePresets": [
      {
        "name": "ninja-release",
        "binaryDir": "${sourceDir}/build/${presetName}",
        "generator": "Ninja",
        "cacheVariables": {
          "CMAKE_BUILD_TYPE": "Release"
        }
      }
    ]
  }

そして次のコマンドラインを実行します：

.. code-block:: console

  cmake -S /path/to/source --preset=ninja-release

これにより :generator:`Ninja` というジェネレータを使って ``/path/to/source/build/ninja-release`` ディレクトリの下に、:variable:`CMAKE_BUILD_TYPE` が ``Release`` タイプであるビルド・ディレクトリを作成します。

その一方で、利用可能なプリセットの一覧を表示したい場合は：

.. code-block:: console

  cmake -S /path/to/source --list-presets

このコマンドラインは ``/path/to/source/CMakePresets.json`` と ``/path/to/source/CMakeUsersPresets.json`` の中で利用できるプリセットの一覧を表示します（表示するだけで、ビルド・ディレクトリは作成しません）。

cmake-gui でプリセットを使う
----------------------------

プロジェクトが ``CMakePresets.json`` または ``CMakeUserPresets.json`` ファイルを介してプリセットを利用できる場合、:manual:`cmake-gui(1)` の Source Directory と Binary Directory との間に、プリセットの一覧がドロップ・ダウンメニューの中に表示されます。
その中からプリセットを選択するとバイナリ・ディレクトリ、ジェネレータ、環境変数、そしてキャッシュ情報がセットされますが、これらのすべてはプリセットを選択したあとで上書きで再設定することも可能です。

ビルドシステムを呼び出す
========================

ビルドシステムを生成した後に、特定のビルド・ツールを呼び出してソフトウェアをビルドすることができます。
ジェネレータが IDE の場合、作成されたプロジェクト・ファイルを IDE にロードしてからビルドします。

CMake はビルドに必要な特定のビルド・ツールを理解しているので、コマンドラインからビルドシステムやプロジェクトをビルドする際は、通常は次のコマンドをビルド・ディレクトリの中で実行します：

.. code-block:: console

  $ cmake --build .

オプション :option:`--build <cmake --build>` は :manual:`cmake(1)` の特定の操作モードを有効にします。
これは :manual:`generator <cmake-generators(7)>` に関連付けられた :variable:`CMAKE_MAKE_PROGRAM` コマンド、またはユーザが設定したビルド・ツールを呼び出します。

さらに :option:`--build <cmake --build>` モードでは、ビルドするターゲットを指定する :option:`--target <cmake--build --target>` オプションも指定できます。「ビルドするターゲット」とは、たとえば特定のライブラリや実行形式、またはカスタム・ターゲットの他に、``install`` のようなジェネレータに依存したターゲットのことです：

.. code-block:: console

  $ cmake --build . --target myexe

さらに :option:`--build <cmake --build>` モードでは、複数の configuration に対応したジェネレータを使用する場合に、どの configuration を使ってビルドするかを指定するオプション :option:`--config <cmake--build --config>` も指定できます：

.. code-block:: console

  $ cmake --build . --target myexe --config Release

この :option:`--config <cmake--build --config>` オプションは、変数の :variable:`CMAKE_BUILD_TYPE` を指定して :manual:`cmake(1)` を実行した時に選択された configuration でビルドシステムを生成した場合は効果はありません。

一部のビルドシステムでは、ビルド中に呼び出されたコマンドラインの詳細なログが省略される場合があります。
そのような場合は :option:`--verbose <cmake--build --verbose>` オプションを指定できます：

.. code-block:: console

  $ cmake --build . --target myexe --verbose

さらに :option:`--build <cmake --build>` モードでは ``--`` のうしろに特定のコマンドライン・オプションを並べると、ビルド時に呼び出されるビルド・ツールにそれらを渡すことができます。
これは、たとえば CMake が提供していない高レベルなユーザ・インタフェースが必要な場面で、ビルド・ジョブが失敗してもビルドを続行するようなオプションを渡したい場合に便利です。

全てのジェネレータで、CMake を呼び出したあとにビルド・ツールを直接呼び出せます。
たとえば、``make`` は :generator:`Unix Makefiles` というジェネレータで生成したビルドシステムの中で実行できます。
あるいは :generator:`Ninja` というジェネレータであれば ``ninja`` コマンドを実行できます。
通常 IDE が生成したビルドシステムではプロジェクトをビルドするための専用のコマンドライン・ツールを提供しています。


ターゲットを選択する
--------------------

CKake のファイルに記述した実行形式とライブラリはそれぞれビルド・ターゲットであり、ビルドシステムによってはビルド途中の作業用、またはユーザが必要とするもの（たとえばドキュメントの生成）をカスタム・ターゲットとして記述する場合があります。

CMake は、CMake ファイルを持つ全てのビルドシステム対して指定できるターゲットを予め定義してあります。

``all``
  ジェネレータが ``Makefile`` と ``Ninja`` の時に指定できるデフォルトのターゲット。
  ビルドシステムの中で、ターゲット・プロパティの :prop_tgt:`EXCLUDE_FROM_ALL` またはディレクトリ・プロパティの :prop_dir:`EXCLUDE_FROM_ALL` で除外されたターゲットを除く、全てのターゲットをビルドする。
  ジェネレータが Xcode と Visual Studio の場合は ``ALL_BUILD`` というターゲットに相当する。
``help``
  ビルド時に利用できる全てのターゲットの一覧を表示する。
  このターゲットはジェネレータが :generator:`Unix Makefiles` または :generator:`Ninja` の場合に指定でき、表示される内容はそのジェネレータが呼び出すビルド・ツールに依存する。
``clean``
  ビルド時に作成されたオブジェクト・ファイルとその他の生成物を削除する。
  ``Makefile`` 系のジェネレータはディレクトリごとに ``clean`` ターゲットを生成するのでディレクトリを個別にクリーンできる。
  ジェネレータが ``Ninja`` の場合は、独自できめの細かい ``-t clean`` システムを利用できる。
``test``
  テストを実行する。
  このターゲットは、CMake ファイルに CTest 系のテストを記述した場合にのみ自動的に利用できるにようになる。
  詳細は `テストを実施する`_ を参照のこと。
``install``
  ビルドしたソフトウェアなどをインストールする。
  このターゲットは、ソフトウェアが :command:`install` コマンドを使ってインストールのルールを定義している場合にのみ自動的に利用できるにようになる。
  詳細は `ソフトウェアをインストールする`_ を参照のこと。
``package``
  ビルドしたバイナリを格納したパッケージを作成する。
  このターゲットは、CMake ファイルに CPack 系のパッケージ作成ルールを記述した場合にのみ自動的に利用できるにようになる。
``package_source``
  ソース・パッケージを作成する。
  このターゲットは、CMake ファイルに CPack 系のパッケージ作成ルールを記述した場合にのみ自動的に利用できるにようになる。

``Makefile`` 系のビルドシステムの場合、 バイナリのビルド・ターゲットの派生型である ``/fast`` というターゲットが提供されます。
この ``/fast`` ターゲットは、依存関係を無視してターゲットをビルドする際に使用します。
これを指定すると、ビルド時に依存関係をチェックせず、バイナリが古い場合は再ビルドは行いません。
:generator:`Ninja` ジェネレータの場合、依存関係のチェックは十分に高速なので、このターゲットは提供されません。

``Makefile`` 系ビルドシステムはさらに、特定のディレクトリの中にあるファイルを個別に前処理したり、アセンブルしたり、コンパイルするためのターゲットも提供しています。

.. code-block:: console

  $ make foo.cpp.i
  $ make foo.cpp.s
  $ make foo.cpp.o

同じ名前で拡張子が異なる別のファイルが存在する場合があるので、拡張子もビルド・ターゲットに含まれます。
ただし拡張子を持たないビルド・ターゲットも提供されます。たとえば：

.. code-block:: console

  $ make foo.i
  $ make foo.s
  $ make foo.o

``foo.c`` と ``foo.cpp`` を持つビルドシステムで、（``.c`` などの拡張子を付けずに） ``foo.i`` をビルド・ターゲットにすると、``foo.c`` と ``foo.cpp`` の両方のファイルが前処理されます。

ビルド・ツールを指定する
------------------------

オプション :option:`--build <cmake --build>` で呼び出されるビルド・ツールは :variable:`CMAKE_MAKE_PROGRAM` 変数にセットしたコマンドで決まります。
ただし、ほとんどのジェネレータで（デフォルトのビルド・ツールが決まっているので）特定のビルド・ツールを設定する必要はありません。

===================== =========================== ===========================
    ジェネレータ       デフォルトのビルド・ツール     代替のビルド・ツール
===================== =========================== ===========================
 XCode                 ``xcodebuild``
 Unix Makefiles        ``make``
 NMake Makefiles       ``nmake``                   ``jom``
 NMake Makefiles JOM   ``jom``                     ``nmake``
 MinGW Makefiles       ``mingw32-make``
 MSYS Makefiles        ``make``
 Ninja                 ``ninja``
 Visual Studio         ``msbuild``
 Watcom WMake          ``wmake``
===================== =========================== ===========================

``jom`` は ``NMake`` 系の makefile を読み取って並列ビルドできる一方で、``nmake`` は常に順番にビルドします。
:generator:`NMake Makefiles` ジェネレータでビルドシステムを生成した後に、ユーザは ``nmake`` の代わりに ``jom`` コマンドも実行できます。
変数 :variable:`CMAKE_MAKE_PROGRAM` に ``jom`` がセットされている時に、:generator:`NMake Makefiles` ジェネレータを使用すると :option:`--build <cmake --build>` で ``jom`` コマンドも呼び出されますが、便宜上、通常の手順で ``jom`` ツールを見つけ出しから変数 :variable:`CMAKE_MAKE_PROGRAM` にセットされたツールとして使用するために、:generator:`NMake Makefiles JOM` ジェネレータが提供されています。
念のため追記しておくと、``nmake`` は :generator:`NMake Makefiles JOM` ジェネレータのビルドシステムで処理できるもう一つ別のビルド・ツールですが、このツールの使用は推奨しません。

ソフトウェアをインストールする
==============================

変数の :variable:`CMAKE_INSTALL_PREFIX` を `CMake キャッシュ`_ にセットしておくと、ソフトウェアのインストール先（*Prefix*）を指定できます。
そのソフトウェアに ``install`` のルールがある場合にインストール先（*Prefix*）を :command:`install` コマンドで指定すると、そのルールに従ってインストール先にビルド結果をインストールします。
Windows の場合のデフォルトのインストール先（*Prefix*）は、アーキテクチャ別の ``Programfiles`` というシステム・ディレクトリが該当します。
Unix 系の場合は ``/usr/local`` がデフォルトのインストール先です。

:variable:`CMAKE_INSTALL_PREFIX` 変数は常にターゲットのファイルシステムにあるインストール先（*Prefix*）を参照します。

したがってクロス・コンパイルやパッケージ作成といった作業で ``sysroot`` 以下には書き込みできない、もしくは ``sysroot`` に手を加えずにそのままの状態にしておきたい場合は、ファイルを「実際に」インストールする場所を :variable:`CMAKE_STAGING_PREFIX` 変数に指定して下さい。

たとえば、次のコマンドを実行すると：

.. code-block:: console

  $ cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local \
    -DCMAKE_SYSROOT=$HOME/root \
    -DCMAKE_STAGING_PREFIX=/tmp/package
  $ cmake --build .
  $ cmake --build . --target install

ファイルはホスト・マシン上の ``/tmp/package/lib/libfoo.so`` というパス名にインストールされます。
そのためホスト・マシン上の ``/usr/local`` というディレクトリは変更されません。

ソフトウェアの中には ``uninstall`` のルールを指定している場合がありますが、CMake はそのようなルールをデフォルトでは生成しません。


テストを実施する
================

:manual:`ctest(1)` コマンドは CMake の配布物に同梱されており、提供されたテストを実施して結果を報告するツールです。
利用可能な全てのテストを実行するために ``test`` というビルド・ターゲットが提供されていますが、この :manual:`ctest(1)` ツールはどのテストを、どのように実行し、その結果をどのように報告するかを細かく制御できます。
なお、ビルド・ディレクトリの中で :manual:`ctest(1)` コマンドを実行することと、``test`` というビルド・ターゲットを実行することは同じです：

.. code-block:: console

  $ ctest

正規表現を渡すことで、その表現と名前がマッチするテストだけ実行できます。
たとえばテストの名前に ``Qt`` という文字が含まれているテストだけを実行する場合は：

.. code-block:: console

  $ ctest -R Qt

同様に正規表現を使って実行するテストを除外することもできます。
たとえばテストの名前に ``Qt`` という文字が含まれていないテストだけ実行する場合は：

.. code-block:: console

  $ ctest -E Qt

:manual:`ctest(1)` にオプションの :option:`-j <ctest -j>` を渡すと、テストを並列実行できます：

.. code-block:: console

  $ ctest -R Qt -j8

あるいは環境変数の :envvar:`CTEST_PARALLEL_LEVEL` を使えば、コマンドラインにこのオプション :option:`-j <ctest -j>` を渡すことを省略できます。

デフォルトで :manual:`ctest(1)` はテストから受け取った出力は表示しません。
オプション :option:`-V <ctest -V>` (or ``--verbose``) を指定すると、全てのテストからの出力を冗長モードにします。
またオプション :option:`--output-on-failure <ctest --output-on-failure>` を指定すると、失敗したテストの出力だけを表示します。
このオプション :option:`--output-on-failure <ctest --output-on-failure>` を :manual:`ctest(1)` コマンドに渡す代わりに、環境変数 :envvar:`CTEST_OUTPUT_ON_FAILURE` に ``1`` を指定しても同等の表示になります。
